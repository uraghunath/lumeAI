package com.lumeai.banking

import com.lumeai.banking.models.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.net.HttpURLConnection
import java.net.URL

/**
 * CounterfactualEngine - Uses REAL GENERATIVE AI (GPT-4o-mini) to generate
 * "What If" scenarios showing paths to approval
 * 
 * NO HARDCODING - Everything generated by AI based on actual decision data
 */
object CounterfactualEngine {
    
    // Azure OpenAI via Grand Central AI Gateway
    private const val OPENAI_API_KEY = "zzzzzzzzzz"
    private const val OPENAI_ENDPOINT = "https://api.hack.lume.services.io/openai/v1"
    private const val OPENAI_MODEL = "gpt-4o-mini"
    private const val AGENT_ID = "zzzzzzzzzz"
    private const val API_VERSION = "2024-08-01-preview"
    
    /**
     * Generate counterfactual scenarios using REAL AI
     * Shows customer what changes would lead to approval
     */
    suspend fun generateCounterfactuals(decision: BankDecision): CounterfactualAnalysis {
        android.util.Log.d("CounterfactualEngine", "üöÄ Calling REAL AI for counterfactual analysis...")
        
        return try {
            val aiResponse = callAIForCounterfactuals(decision)
            parseCounterfactualResponse(aiResponse, decision)
        } catch (e: java.net.UnknownHostException) {
            android.util.Log.e("CounterfactualEngine", "‚ùå Network error", e)
            generateFallbackCounterfactuals(decision, "No internet connection")
        } catch (e: java.net.SocketTimeoutException) {
            android.util.Log.e("CounterfactualEngine", "‚ùå Timeout", e)
            generateFallbackCounterfactuals(decision, "AI service timeout")
        } catch (e: java.io.IOException) {
            android.util.Log.e("CounterfactualEngine", "‚ùå IO Error: ${e.message}", e)
            generateFallbackCounterfactuals(decision, "Connection error")
        } catch (e: org.json.JSONException) {
            android.util.Log.e("CounterfactualEngine", "‚ùå JSON parsing error", e)
            generateFallbackCounterfactuals(decision, "AI response error")
        } catch (e: Exception) {
            android.util.Log.e("CounterfactualEngine", "‚ùå Unexpected error: ${e.message}", e)
            generateFallbackCounterfactuals(decision, "Service error")
        }
    }
    
    /**
     * Call OpenAI to generate counterfactual scenarios
     */
    private suspend fun callAIForCounterfactuals(decision: BankDecision): String {
        return withContext(Dispatchers.IO) {
            val prompt = buildCounterfactualPrompt(decision)
            
            val azureUrl = "$OPENAI_ENDPOINT/deployments/$OPENAI_MODEL/chat/completions?api-version=$API_VERSION"
            val url = URL(azureUrl)
            val connection = url.openConnection() as HttpURLConnection
            
            android.util.Log.d("CounterfactualEngine", "üì° Calling Azure OpenAI for counterfactuals...")
            
            try {
                connection.requestMethod = "POST"
                connection.setRequestProperty("Content-Type", "application/json")
                connection.setRequestProperty("api-key", OPENAI_API_KEY)
                connection.setRequestProperty("x-agent-id", AGENT_ID)
                connection.doOutput = true
            connection.connectTimeout = 120000  // Increased to 120 seconds (2 minutes)
            connection.readTimeout = 120000     // Increased to 120 seconds (2 minutes)
                
                val requestBody = JSONObject().apply {
                    put("messages", org.json.JSONArray().apply {
                        put(JSONObject().apply {
                            put("role", "system")
                            put("content", "You are a banking AI that generates counterfactual 'what if' scenarios. Always respond with valid JSON showing alternative paths to approval.")
                        })
                        put(JSONObject().apply {
                            put("role", "user")
                            put("content", prompt)
                        })
                    })
                    put("temperature", 0.5)
                    put("max_tokens", 2000)
                    put("response_format", JSONObject().put("type", "json_object"))
                }
                
                connection.outputStream.use { os ->
                    os.write(requestBody.toString().toByteArray())
                }
                
                val responseCode = connection.responseCode
                if (responseCode == HttpURLConnection.HTTP_OK) {
                    val response = connection.inputStream.bufferedReader().use { it.readText() }
                    val jsonResponse = JSONObject(response)
                    val content = jsonResponse.getJSONArray("choices")
                        .getJSONObject(0)
                        .getJSONObject("message")
                        .getString("content")
                    
                    android.util.Log.d("CounterfactualEngine", "‚úÖ AI generated counterfactuals: ${content.take(200)}...")
                    content
                } else {
                    throw Exception("API Error: $responseCode")
                }
            } finally {
                connection.disconnect()
            }
        }
    }
    
    /**
     * Build comprehensive prompt for AI to generate counterfactuals
     */
    private fun buildCounterfactualPrompt(decision: BankDecision): String {
        val failedFactors = decision.factors.filter { !it.passed }
        val passedFactors = decision.factors.filter { it.passed }
        
        val factorsDesc = failedFactors.joinToString("\n") { 
            "- ${it.technicalName}: Current=${it.value}, Required=${it.threshold}, Weight=${it.weight}"
        }
        
        return """
You are analyzing a bank decision to generate "What If" counterfactual scenarios.

DECISION TYPE: ${decision.decisionType}
CUSTOMER: Age ${decision.customerProfile.age}, ${decision.customerProfile.locationType}, ${decision.customerProfile.digitalLiteracy} digital literacy

FAILED FACTORS (causing rejection):
$factorsDesc

PASSED FACTORS: ${passedFactors.size} factors already met

TASK: Generate 3-5 counterfactual scenarios showing different paths to approval.

For EACH scenario, calculate:
1. scenarioName: Short descriptive name (e.g., "Improve Credit Score")
2. changeRequired: What specific change is needed
3. fromValue: Current value in simple terms
4. toValue: Target value needed for approval
5. impactOnApproval: Estimated % increase in approval probability (0-100)
6. difficulty: "Easy", "Moderate", or "Hard"
7. timeframe: How long this would take (e.g., "3-6 months")
8. costEstimate: Estimated cost (e.g., "Free", "‚Çπ5,000", "‚Çπ50,000")
9. actionSteps: Array of 3-5 specific steps to achieve this change
10. keyBenefit: Why this path is good (1 sentence)

IMPORTANT CALCULATION RULES:
- impactOnApproval should be proportional to factor weight (weight 0.35 = ~35% impact)
- If multiple factors need fixing, suggest combination scenarios
- Consider customer's demographics (age, location) when suggesting difficulty
- Make timeframes realistic (credit score: 6-12 months, income proof: immediate)
- Order scenarios by effectiveness (highest impact first)

OUTPUT FORMAT (JSON):
{
  "overallMessage": "Summary of what customer needs to do (2 sentences)",
  "easiestPath": "Name of easiest scenario to achieve",
  "fastestPath": "Name of fastest scenario",
  "mostImpactful": "Name of highest impact scenario",
  "scenarios": [
    {
      "scenarioName": "...",
      "changeRequired": "...",
      "fromValue": "...",
      "toValue": "...",
      "impactOnApproval": 75,
      "difficulty": "Moderate",
      "timeframe": "6-12 months",
      "costEstimate": "Free",
      "actionSteps": ["step1", "step2", "step3"],
      "keyBenefit": "..."
    }
  ]
}

Generate realistic, actionable scenarios based on actual banking criteria.
""".trim()
    }
    
    /**
     * Parse AI response into structured counterfactual analysis
     */
    private fun parseCounterfactualResponse(aiContent: String, decision: BankDecision): CounterfactualAnalysis {
        val json = JSONObject(aiContent)
        
        val scenariosArray = json.getJSONArray("scenarios")
        val scenarios = mutableListOf<CounterfactualScenario>()
        
        for (i in 0 until scenariosArray.length()) {
            val scenarioJson = scenariosArray.getJSONObject(i)
            
            val actionSteps = mutableListOf<String>()
            val stepsArray = scenarioJson.getJSONArray("actionSteps")
            for (j in 0 until stepsArray.length()) {
                actionSteps.add(stepsArray.getString(j))
            }
            
            scenarios.add(CounterfactualScenario(
                scenarioName = scenarioJson.getString("scenarioName"),
                changeRequired = scenarioJson.getString("changeRequired"),
                fromValue = scenarioJson.getString("fromValue"),
                toValue = scenarioJson.getString("toValue"),
                impactOnApproval = scenarioJson.getInt("impactOnApproval"),
                difficulty = scenarioJson.getString("difficulty"),
                timeframe = scenarioJson.getString("timeframe"),
                costEstimate = scenarioJson.getString("costEstimate"),
                actionSteps = actionSteps,
                keyBenefit = scenarioJson.getString("keyBenefit")
            ))
        }
        
        return CounterfactualAnalysis(
            overallMessage = json.getString("overallMessage"),
            easiestPath = json.getString("easiestPath"),
            fastestPath = json.getString("fastestPath"),
            mostImpactful = json.getString("mostImpactful"),
            scenarios = scenarios.sortedByDescending { it.impactOnApproval },
            isAIGenerated = true
        )
    }
    
    /**
     * Emergency fallback with error transparency (rarely used)
     */
    private fun generateFallbackCounterfactuals(decision: BankDecision, errorReason: String = "Service unavailable"): CounterfactualAnalysis {
        val scenarios = mutableListOf<CounterfactualScenario>()
        
        // Find top failed factor
        val topFactor = decision.factors.filter { !it.passed }
            .maxByOrNull { it.weight }
        
        if (topFactor != null) {
            scenarios.add(CounterfactualScenario(
                scenarioName = "Improve ${topFactor.technicalName}",
                changeRequired = "Increase from ${topFactor.value} to ${topFactor.threshold}",
                fromValue = topFactor.value,
                toValue = topFactor.threshold,
                impactOnApproval = (topFactor.weight * 100).toInt(),
                difficulty = "Moderate",
                timeframe = "3-6 months",
                costEstimate = "Varies",
                actionSteps = listOf(
                    "Review current status",
                    "Create improvement plan",
                    "Monitor progress monthly"
                ),
                keyBenefit = "Highest impact on approval"
            ))
        }
        
        return CounterfactualAnalysis(
            overallMessage = "‚ö†Ô∏è $errorReason. Using backup analysis system.\n\nContact bank for detailed improvement guidance.",
            easiestPath = scenarios.firstOrNull()?.scenarioName ?: "Contact bank",
            fastestPath = scenarios.firstOrNull()?.scenarioName ?: "Contact bank",
            mostImpactful = scenarios.firstOrNull()?.scenarioName ?: "Contact bank",
            scenarios = scenarios,
            isAIGenerated = false
        )
    }
}

/**
 * Complete counterfactual analysis
 */
data class CounterfactualAnalysis(
    val overallMessage: String,
    val easiestPath: String,
    val fastestPath: String,
    val mostImpactful: String,
    val scenarios: List<CounterfactualScenario>,
    val isAIGenerated: Boolean
)

/**
 * Individual "What If" scenario
 */
data class CounterfactualScenario(
    val scenarioName: String,
    val changeRequired: String,
    val fromValue: String,
    val toValue: String,
    val impactOnApproval: Int, // 0-100
    val difficulty: String, // Easy, Moderate, Hard
    val timeframe: String,
    val costEstimate: String,
    val actionSteps: List<String>,
    val keyBenefit: String
)

